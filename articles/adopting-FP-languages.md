---
title: "関数型言語を採用し、維持し、継続する"
emoji: ""
type: "tech"
topics:
  - erlang
  - elixir
  - elm
published: false
publication_name: siiibo_tech
marp: true
theme: gaia
class: invert
paginate: true
---

<!-- _class: [lead, invert] -->

## 関数型言語を採用し、維持し、継続する

By [松澤 有 (ymtszw)](https://zenn.dev/ymtszw) (Siiibo証券株式会社 CTO)
@[関数型まつり2025](https://2025.fp-matsuri.org/) (2025/06/14) [^1]

[^1]: この発表資料はZennで公開しつつ、[Marp](https://marp.app/)スライドとして作成しているので水平線がいっぱい入っています

---

### [Siiibo証券株式会社](https://siiibo.com/)

- 2019年創業、筆者はfounding engineer / CTO
- ↓の構成で社債専門の証券システムを作り上げてきた

![w:600 言語構成](/images/siiibo-languages.png)

---

### このセッションでは

- 実際に関数型言語を業務で採用し、維持し、継続するにあたって重視している価値観、手続き、手法などをざっくばらんに紹介します
- なんとか5年はやってこれた
- 次の5年もやっていきたいがためのやつ

---

### 前提

- 最新の開発組織規模
  - フルタイム - 5名（筆者含む）
  - 週3日程度 - 2名
  - 週2〜10時間程度 - 8名
  - 学生アルバイト - 3名
- 1日あたりの平均デプロイ（master push）回数
  - Copilotにお願いして雑に集計したら**4.94**だった

```sh
$ set start_date (git log master --reverse --pretty=format:'%ad' --date=short | head -1); set end_date (git log master --pretty=format:'%ad' --date=short | head -1); set days (math (date -j -f "%Y-%m-%d" $end_date "+%s") - (date -j -f "%Y-%m-%d" $start_date "+%s")); set days (math "ceil(($days/86400)+1)"); set commits (git rev-list --count master); math "$commits / $days"
4.941361
```

---

<!-- _class: [lead, invert] -->
## 狂気

---

### 「技術選定」

- CTOとかFounding Engineerが技術構成を選ぶにあたっての観点
  - まともな**モノ**を継続的に提供するに足る機能があるか
  - それを実際につくる**ヒト**を継続的に集められるか
- 加えて「スタートアップ」なら、
  - （上記2点を説得材料として）**カネ**を集められるか

<!-- カッコ付きのタイトル -->
<!-- 「まとも」とは？ -->
<!-- 既存組織内での採用でもある程度共通するはず -->

---

### 「メインストリーム」

- ElixirやElmを含む関数型言語の多くは「メインストリーム」とは目されていない[^要出典]
  - 10年前のEvan氏: ["Let's be Mainstream!"](https://www.youtube.com/watch?v=oYk8CKH7OhE)
- モノ・ヒト・カネの要素を自信を持って揃えるには弱い...

<!-- 同じくカッコ付き -->

---

### ...とか言ってられるか

- 良いと感じた技術があって、良いモノを作れると検証できたのであれば、あとは自分がやるかどうかでしかない
  - というか、勝手に機会が降ってくることがない
- ある種の狂気を必要とする点で、非メインストリームな技術採用はスタートアップ起業自体と似ている
  - その試み自体が仮説検証であり、失敗にもまた学びがあるが、結局は勇気と周りを巻き込んで走り続ける力

---

### 「支え」となるもの

- とはいえ「この技術がイイらしい、とりあえずやってみよう」は爆発しそう
  - そこまで無根拠なのは蛮勇
- 何が支えとなって一歩を踏み出せるのか？

**筆者の考えとしては**：

---

### その言語での「良いコード」に対する土地勘

- 本チャンの業務で採用する前に「**検証**」は必須
  - 言うまでもないこと？
  - 個人プロダクトでも、別業務内の軽いツール開発などでもいい
  - そこそこ大きなコードベースを作って勘所を押さえておくこと
  - 先行しているOSSのコードを読んで、先人の開拓した領域に触れておくこと
- 筆者の場合は...

---

#### Elixir

- そもそも前職でかなりElixirを業務で書いて自信をつけていた
  - [access-company/antikythera](https://github.com/access-company/antikythera) - Elixir製マルチテナントアプリケーションプラットフォーム
- 個人的にも業務内外でElixirをかなりの時間書いた
  - [blick](https://github.com/ymtszw/blick) - Antikythera上で動く勉強会スライド集積アプリ
  - [hipchat_elixir](https://github.com/ymtszw/hipchat_elixir) - 今は亡きHipChatのclientをSwaggerから自動生成
- 現職でも必要に応じてOSSリリースしている
  - [siiibo/assert_match](https://github.com/siiibo/assert_match) - Pipeline-friendlyなassertionマクロ

---

#### Elm

- こちらは業務採用には至らなかったがやはり相当書いたし、今も新しいことを試す場をいくつか持っている
  - [ymtszw.cc](https://ymtszw.cc/) - Elm & elm-pagesで書いてる個人ページ
  - [elm-xml-decode](https://github.com/ymtszw/elm-xml-decode) - XmlのApplicative-FunctorなDecoderパッケージ
  - [setem](https://github.com/ymtszw/setem) - 直接Elm製ではないが、Elmのコード生成をするツール

---

#### 主観は大事

- 世の中の採用事例とかを情報として集めておくのも（自分以外に対する）説得材料としては役に立つ
- ...が、究極的には**主観**だと思っている
  - この言語で5年10年戦えるか？実現したい要求に叶うか？飽きないか？
- プラス、「何らか行き詰まったときに捨てやすいか？」という観点もある
  - これは言語自体というよりアプリケーションアーキテクチャでそれなりに担保できる

<!-- 詳細書くかも -->

---

### コードレビューの技術

- 何らかの技術要素を採用して業務に挑もうとするとき、必然的にFounding Engineerはコードレビューをする立場
  - 自分がいいと思う技術であっても、それを「伝道」できなければあとが続かない
- 健全で有意義なコードレビューのやり取りがどのようなものか？という経験とその内面化
  - 何をもって「できている」と言えるのかがそもそも難しいので、ここでも主観大事だしずっと研究が続く
  - マジで**環境に依存する**と思うので若いエンジニアには特に言っている
  - 筆者の個人的な経験としては前職（新卒入社）のチームが本当に素晴らしかった...そこで私のすべてが形作られた
- この話は直接次の章につながる

---

### ここまでのまとめ

- 非メインストリーム技術採用は狂気ドリブンで機会を自ら作り出すもの
- 事前検証と伝道師としてのコードレビュー技術が支えになる

---

<!-- _class: [lead, invert] -->
## コードレビュー / CI / Upkeep

ルーチン業務で重視する要素

---

### コードレビュー

- 「どういうコードが（チームにとって・製品にとって）良いコードか」の伝道事業
  - 伝「**道**」であることが大事
  - 感覚・信念として共有できる状態に持っていきたい
- よく引き合いに出す資料：
  - [How to Pull Request](https://medium.com/google-developer-experts/how-to-pull-request-d75ac81449a5) by Google Developer Experts
  - レビュイーとレビュワー、両方の視点で意識すると良いことがまとまっている

---

#### 永遠の事業

- **コードレビューに終わりはない**
  - 人は忘れる（レビューする側も、される側も）
  - 新しい人は入る
  - 一度言っただけで身につくことは誰であれ、ない
- 言葉を尽くして、繰り返し対話し続ける

---

#### 自動化する

- レビュー指摘項目のうち、自動的に強制できるものは早めに自動化して機械にやらせる
  - Formatterで強制できるコードスタイル
  - Linterで強制できる観点
- これがやりやすいか言語か、標準ツールが存在するか、というのは当該言語に対する大きな加点項目
  - 少なくともElixir/Elmでは長いことformatの議論をしてない
    - Nearly-zero-configなformatterが標準
    - 公式formatterのスタイルが好きじゃない、という状況はたまにあるが、考えることを減らせるメリットのほうが大きいので割り切っている

---

### CI

- 自動化ツールの導入はCIとセット
- 人間は忘れるのだから、忘れない機械に何でもチェックさせる
  - FormatterやLinter, テストの実行以外だと：
    - 破壊的変更（DB-Server間や、Server-Client間）の検知
    - 自動生成コードのコミット漏れの検知

---

### Upkeep

---

## ビルドとテストの高速化

- 関数型言語はAOTコンパイルが多い
- プロダクトが育つとビルドやテストが遅くなりがち
- 高速化のための取り組みや工夫

---

## 静的型付けでない言語と型の話

- 静的型付けでない言語でも型は重要
- ElmとElixirで開発することで生じる型への感覚
- Elixirに型がやってくる話

---

## 情報収集 / コミュニティ還元

- ほっといても情報が入ってくる言語ではない
- アクティブに情報を集める必要性
- コミュニティへの還元や採用戦略との関係

---

## 新しい手法を取り入れる

- E2Eテストやelm-reviewによるlint・コード自動生成
- AIコード支援など新しい道具の導入
- 当初はなかった手法を後から取り入れる柔軟性

---

## 覚悟

- 最終的には覚悟が必要
- 継続・維持のために大切なこと
